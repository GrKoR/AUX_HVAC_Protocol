# Описание UART-протокола wifi-модулей кондиционеров, произведенных на заводах AUX.

## Параметры UART
Скорость: 4800
Формат: 4800/8-E-1
Описание: один стартовый `0`, 8 бит данных, один бит четности (равен `1`, если в битах данных нечетное количество единиц) и одна стоповая единица, передача на скорости 4800 бод.


<span id="packet_structure"/>

## Структура пакета
Каждое сообщение, передаваемое по UART, имеет:
1. **заголовок**: 8 байт;
2. **тело**: от 0 до X байт;
3. **контрольную сумму**: 2 байта, CRC16.

> **Примечание**
> Максимальная длина пакета для известных команд составляет 34 байта. Единственное исколючение - кондиционеры `Royal Clima` (как минимум, модель CO-D xxHNI). Для них длина большого пакета включая заголовки и CRC составляет 35 байт (в конец тела добавлен нулевой байт). Остальные пакеты по длине и структуре полностью соответствуют стандарту.

<span id="packet_header"/>

### Заголовок
Это обязательная часть пакета длиной 8 байт:
| # | NAME  | значение |
| - | ----- | -------- |
| 0 | START | 0xBB |
| 1 | ?     | 0x00 |
| 2 | TYPE  | 0x01 |
| 3 | wifi? | 0x00 |
| 4 | ?     | 0x00 |
| 5 | ?     | 0x00 |
| 6 | LEN   | 0x00 |
| 7 | ?     | 0x00 |


<span id="packet_header_0"/>

##### Байт 0, START
Стартовый байт. Всегда равен `0xBB`.



<span id="packet_header_1"/>

##### Байт 1, (?)
Не расшифрован. Во всех встреченных пакетах был равен `0x00`.



<span id="packet_header_2"/>

##### Байт 2, TYPE
Тип пакета. Встречались только эти:
- `0x01` (**направление:** входящий, исходящий)

  ping-пакет. Пакеты этого типа идут от кондиционера автоматически каждые 2,963 сек. Wifi-модуль отвечает на них пакетами того же типа. Без входящего дежурного пакета wifi-модуль пакеты такого типа не рассылает.
- `0x06` (**направление:** исходящий)

  команда сплиту на выполнение. Отправляется wifi-модулем, когда это необходимо. Тип команды зашит в теле пакета. Длина тела - 2 байта.
- `0x07` (**направление:** входящий)
  
  информационный пакет. Отправляется кондиционером в адрес wifi-модуля. Может быть как ответом на запрос wifi-модуля, так и быть отправленным кондиционером без каких-либо запросов.

- `0x09` (**направление:** входящий, исходящий)

  инициирование WiFi модуля. Отправляется кондиционером, когда кнопка HEALTH нажимается 8 раз за 10 сек. В работе самодельного wifi-модуля не используется, так как в этом нет необходимости. Wifi-модуль на неё отвечает пакетом того же типа.

  Для входящего пакета длина тела пакета всегда 1 байт. Этот байт всегда был равен `0x02`.
  
  Для исходящего пакета тело отсутствует.

- `0x0b` (**направление:** исходящий)
  
  посылка с такой командой отправляется wifi-модулем, если он не получает ping-пакетов кондера. Также wifi-модуль посылает такие пакеты в каких-то случаях, но в логике этого процесса я не разобрался. Самодельный wifi-модуль успешно работает и без этой команды.

  Длина тела пакета всегда 2 байта.
  
  Первый байт тела - какой-то счетчик. То ли счетчик попыток, то ли что-то подобное. Встречались значения `0x01`, `0x02` и `0x03`.

  Второй байт тела пакета всегда `0x00`.



<span id="packet_header_3"/>

##### Байт 3, wifi?
Скорее всего признак пакета wifi-модуля.
Для всех сообщений, посылаемых модулем, этот байт равен `0x80`.
Для всех сообщений, посылаемых сплитом, этот байт равен `0x00`.



<span id="packet_header_4"/>

##### Байт 4, (?)
Не расшифрован. Встречаются значения `0x00` и `0x01`.
- `0x01` встречается только в исходящих пакетах (которые отправляет wifi-модуль кондиционеру) и только для пакетов с TYPE равным `0x01` и `0x09`.
- `0x00` встречается в исходящих пакетах с TYPE равным `0x06` и `0x0b`. А также во всех входящих пакетах (TYPE = `0x01`, `0x07`, `0x09`)


<span id="packet_header_5"/>

##### Байт 5, (?)
Не расшифрован. Во всех встреченных пакетах был равен `0x00`.


<span id="packet_header_6"/>

##### Байт 6, LEN
длина тела пакета в байтах.

Длина тела разная для пакетов разных типов:
| TYPE | направление | длина пакета |
| ---- | ----------- | ------------ |
| `0x01` | [=>] | 8 байт |
| `0x01` | [<=] | 0 байт |
| `0x06` | [=>] | 2 или 15 байт; подробнее в описании пакета TYPE = `0x06` |
| `0x07` | [<=] | 4, 15 или 23 байта; подробнее в описании пакета TYPE = `0x07` |
| `0x09` | [=>] | 0 байт |
| `0x09` | [<=] | 1 байт |
| `0x0B` | [=>] | 2 байта |



<span id="packet_header_7"/>

##### Байт 7, (?)
Не расшифрован. Во всех встреченных пакетах был равен `0x00`.


### Тело пакета
Это не обязательная часть пакета. Длина тела указана в **байте 6 (LEN)** заголовка. Структура тела зависит от типа пакета, переданного в заголовке.


<span id="packet_crc"/>

### Контрольная сумма
Это CRC16 для заголовка + тела пакета.



<span id="packet_types"/>

## Типы пакетов
На сегодня известны следующие типы пакетов:
- [**0x01: Ping-пакет.**](#packet_type_ping) Рассылается кондиционером каждые 3 сек.; модуль на него отвечает
- [**0x06: команда кондиционеру.**](#packet_type_cmd) Модуль отправляет такие команды, когда что-то хочет от сплита
- [**0x07: информирование.**](#packet_type_info) Бывает 3 видов. Один из них рассылается кондиционером самостоятельно раз в 10 мин. и все 3 могут быть ответом на запросы модуля.
- [**0x09: инициирование wifi-модуля.**](#packet_type_init) Присылается сплитом, если кнопка HEALTH на пульте нажимается 8 раз; как там и что работает - не разбирался. Для работы самодельного донгла эти пакеты не актуальны. Скорее всего, нужно на этапе настройки оригинального донгла (задание ему сети wifi, паролей и т.п.).
- [**0x0B: не понятно.**](#packet_type_unkn) Какой-то странный пакет, отправляемый wifi-модулем при инициации и иногда при включении питания... как работает и зачем нужен - не разбирался, сплит на него вроде бы не реагирует.

<span id="packet_type_ping"/>

### 0x01: Ping-пакет
---

Пакеты этого типа идут от кондиционера автоматически примерно каждые 3 секунды. Wifi-модуль отвечает на них пакетами этого же типа.

Стандартный вид входящего ping-пакета:
| # | NAME  | значение |
| - | ----- | -------- |
| 0 | START | 0xBB |
| 1 | ?     | 0x00 |
| 2 | TYPE  | 0x01 |
| 3 | wifi? | 0x00 |
| 4 | ?     | 0x00 |
| 5 | ?     | 0x00 |
| 6 | LEN   | 0x00 |
| 7 | ?     | 0x00 |
| 8 | CRC1  | 0x43 |
| 9 | CRC2  | 0xFF |


Стандартный вид исходящего ping-пакета:
| #  | NAME  | значение |
| -- | ----- | -------- |
| 0  | START | 0xBB |
| 1  | ?     | 0x00 |
| 2  | TYPE  | 0x01 |
| 3  | wifi? | 0x80 |
| 4  | ?     | 0x01 |
| 5  | ?     | 0x00 |
| 6  | LEN   | 0x08 |
| 7  | ?     | 0x00 |
| 8  |       | 0x1C |
| 9  |       | 0x27 |
| 10 |       | 0x00 |
| 11 |       | 0x00 |
| 12 |       | 0x00 |
| 13 |       | 0x00 |
| 14 |       | 0x00 |
| 15 |       | 0x00 |
| 16 | CRC1  | 0x1E |
| 17 | CRC2  | 0x58 |

Иногда встречалось такое, что младший байт CRC у входящего пакета (`0xFF`) отсутствует. Это “битый” пакет. Чаще всего wifi-модуль на такой не отвечает. Но тоже не всегда :) В общем, “всё гибко” :)

Входящий ping-пакет всегда одинаков (за исключением битых пакетов с отсутствующим `0xFF` в CRC). Ответ wifi-модуля тоже одинаков. По крайней мере никаких вариаций за всё время наблюдений не встретилось.

Есть предположение насчет отсутствия `0xFF` в конце.
Похоже, такое встречается, когда пинг-пакет совпадает по таймингу с дежурным информационным пакетом (TYPE=`0x07`, CMD=`0x2x`). В этом случае в кондее происходит какой-то баг, и два пакета “слипаются”. Пакет TYPE=`0x07` прилипает к ответу на пинг между первым и вторым байтом CRC. То есть положенная последняя `0xFF` в ответе на пинг прилетает уже после пакета TYPE=`0x07`.



<span id="packet_type_cmd"/>

### 0x06: команда кондиционеру
---

Это всегда исходящий пакет. В нем wifi-модуль передаёт команды кондиционеру или же запрашивает информацию о состоянии.

Тело пакета имеет длину 2 или 15 байт. Причем для любого тела первые два байта будут командой и каким-то флагом.

Примеры пакетов для разных команд:

Исходящий пакет:
| #  | NAME  | вар.1  | вар.2  | | NAME  | вар.3  |
| -- | ----- | ------ | ------ |-| ----- | ------ |
| 0  | START | `0xBB` | `0xBB` | | START | `0xBB` |
| 1  | ?     | `0x00` | `0x00` | | ?     | `0x00` |
| 2  | TYPE  | `0x06` | `0x06` | | TYPE  | `0x06` |
| 3  | wifi? | `0x80` | `0x80` | | wifi? | `0x80` |
| 4  | ?     | `0x00` | `0x00` | | ?     | `0x00` |
| 5  | ?     | `0x00` | `0x00` | | ?     | `0x00` |
| 6  | LEN   | `0x02` | `0x02` | | LEN   | `0x02` |
| 7  | ?     | `0x00` | `0x00` | | ?     | `0x00` |
| 8  | CMD   | `0x21` | `0x11` | | CMD   | `0x01` |
| 9  | ?X    | `0x01` | `0x01` | | ?X    | `0x01` |
| 10 | CRC1  | `0x1B` | `0x2B` | |       | `0x97` |
| 11 | CRC2  | `0x7E` | `0x7E` | |       | `0x00` |
| 12 |       |        |        | |       | `0x02` |
| 13 |       |        |        | |       | `0x60` |
| 14 |       |        |        | |       | `0x00` |
| 15 |       |        |        | |       | `0x20` |
| 16 |       |        |        | |       | `0x00` |
| 17 |       |        |        | |       | `0x00` |
| 18 |       |        |        | |       | `0x00` |
| 19 |       |        |        | |       | `0x00` |
| 20 |       |        |        | |       | `0x00` |
| 21 |       |        |        | |       | `0x00` |
| 22 |       |        |        | |       | `0x00` |
| 23 |       |        |        | | CRC1  | `0x94` |
| 24 |       |        |        | | CRC2  | `0xFD` |

##### Байт 8 (CMD)
одна из следующих команд кондиционеру:
- `0x01` -  команда управления.
   
   Тело команды имеет тот же состав и структуру, что и тело пакета TYPE = `0x07`, CMD = `0x11` на 25 байт. В ответ на команду приходит входящий пакет TYPE = `0x07`, CMD = `0x01` на 14 байт.

- `0x11` - запрос информации о работе внутреннего блока сплит-системы.

  В ответ приходит пакет TYPE = `0x07` на 25 байт. Они появились уже после подключения модуля к WiFi. Идут периодически сами по себе (без запроса).
 
- `0x21` - запрос информации о работе внешнего блока сплит-системы.
  
  В ответ приходит пакет TYPE = `0x07` на 34 байта. Такие запросы модуль делал и до подключения к WiFi. Идут периодически сами по себе (без запроса).


##### Байт 9 (?X)
непонятен.

Есть предположение, что этот же байт возвращается во воходящем пакете TYPE = `0x07` в байте 8.

> **Предположение №1:** это может быть ID запроса или порядковый номер запроса. Если будет тяга к экспериментам, то надо попробовать передать подряд две команды, для первой указать `0x01`, для второй `0x02`. И посмотреть на ответы.

> **Предположение №2:** Стоит попробовать в исходящем пакете в этом месте передать отличный от `0x01` байт. И посмотреть, вернётся он в восьмом байте ответа или нет. Тогда по крайней мере станет понятно, связан этот байт с байтом 8 воходящего пакета TYPE = `0x07`.

##### Байты 10..22
присутствуют только в пакетах TYPE = `0x06` для команды CMD = `0x01`. Их значение идентично телу пакета TYPE = `0x07`, CMD = `0x11` (описание [смотри там же](#type07cmd11)).


<span id="packet_type_info"/>

### 0x07: информирование
---

Пакетом данного типа кондиционер информирует wifi-модуль о результатах выполнения команды либо сообщает статус внутреннего или внешнего блока.


<span id="packet_cmd_2x"/>

#### CMD 0x2x: Дежурное информирование
Этот пакет отправляется сплитом в дежурном режиме каждые 10 минут. Wifi-модуль на него не отвечает.

В пакете содержится информация о работе внешнего блока сплит-системы. Значение байтов тела пакета такое же, как для входящего пакета CMD = `0x21` со статусом внешнего блока сплит-системы ([см. ниже](#packet_cmd_21)).

Отличия только в **байте 9 (CMD)**:
- Когда модуль wifi не подключен к кондиционеру, в этом байте сплит может передавать значения от `0x20` до `0x2F`. После `0x2F` идет опять `0x20`.
 
  Что это за счетчик, не особо понятно.
  
  Значение счетчика меняется, если сплиту отправить какой-нибудь левый пакет с компьютера. Учитываются как минимум 8*HEALTH (результат в виде команды `0x09` в линии), а также передаваемые сплиту по USART команды с CMD=`0x02`. 

- Когда wifi-модуль подключен к сплиту, в этом байте возвращается модулю код команды CMD, полученный от модуля в пакете с TYPE=`0x06`.

- **Важно!** При подключенном модуле тоже есть дежурные пакеты, присылаемые каждые 10 минут. При этом код в байте 9 может быть любой из интервала `0x20`..`0x2F`.


<span id="packet_cmd_21"/>

#### CMD 0x21: Статус внешнего блока сплит-системы
В пакете содержится информация о работе внешнего блока сплит-системы.

Пакет отправляется кондиционером в ответ на команду wifi-модуля с TYPE = `0x06` и CMD = `0x21`.

Входящий пакет:
| #  | NAME  | значение |
| -- | ----- | -------- |
| 0  | START | `0xBB` |
| 1  | ?     | `0x00` |
| 2  | TYPE  | `0x07` |
| 3  | wifi? | `0x00` |
| 4  | ?     | `0x00` |
| 5  | ?     | `0x00` |
| 6  | LEN   | `0x18` |
| 7  | ?     | `0x00` |
| 8  | [?X](#packet_cmd_21_x)    | `0x01` |
| 9  | [CMD](#packet_cmd_21_cmd)   | `0x21` |
| 10 | [CONF](#packet_cmd_21_conf)  | `0xC0` |
| 11 | [MODE](#packet_cmd_21_mode)  | `0x3D` |
| 12 | [FRST](#packet_cmd_21_frst)  | `0x00` |
| 13 | [FSPD](#packet_cmd_21_fspd)  | `0x02` |
| 14 | [FPWM](#packet_cmd_21_fpwm)  | `0x54` |
| 15 | [Tint](#packet_cmd_21_tint)  | `0x3A` |
| 16 |       | `0x00` |
| 17 | To    | `0x29` |
| 18 |       | `0x00` |
| 19 |       | `0x00` |
| 20 | iT    | `0x00` |
| 21 |       | `0x00` |
| 22 |       | `0x00` |
| 23 |       | `0x00` |
| 24 | iPwr  | `0x00` |
| 25 |       | `0x00` |
| 26 |       | `0x00` |
| 27 |       | `0x00` |
| 28 |       | `0x00` |
| 29 |       | `0x00` |
| 30 |       | `0x00` |
| 31 | Tid   | `0x05` |
| 32 | CRC1  | `0x10` |
| 33 | CRC2  | `0x36` |


<span id="packet_cmd_21_x"/>

##### Байт 8 (?X)
Не понятно, что это. Всегда встречался только `0x01`.

Есть предположение, что это тот же байт `0x01`, который передает wifi-модуль в пакете TYPE = `0x06` в байте 9 (?x).

В описании к пакету TYPE = `0x06` ([см. тут](#packet_type_cmd)) описана пара возможных экспериментов с этим байтом.


<span id="packet_cmd_21_cmd"/>

##### Байт 9 (CMD)
возвращает wifi-модулю код типа команды CMD, полученный в пакете TYPE = `0x06`.


<span id="packet_cmd_21_conf"/>

##### Байт 10 (CONF)
До конца не расшифрован.

Есть предположение, что этот байт информирует о типе кондиционера. Как минимум, инверторный он или on-off.

Если предположение верное, то значения этого байта такое:
- `0xC0` (1100 0000) - обычный on-off сплит;
- `0xE0` (1110 0000) - инверторный сплит, пакет с ответом на запрос; 
- `0xE4` (1110 0100) - инверторный сплит, пакет дежурного информирования. Встречается в логах с периодом порядка 10 минут.

**Бит 5**: `1` для инверторных сплитов, `0` для сплитов on-off.


<span id="packet_cmd_21_mode"/>

##### Байт 11 (MODE)
до конца не расшифрован.

Похоже, этот байт как-то связан с режимом работы внешнего блока сплита (выкл, охлаждение, обогрев, осушение).

Встречавшиеся в логах значения:
- `0x04` (0000 0100) - ?? сплит выключен, до этого работал (статус держится 1 час после выключения)
- `0x05` (0000 0101) - AUTO
- `0x24` (0010 0100) - OFF
- `0x25` (0010 0101) - COOL
- `0x39` (0011 1001) - ??
- `0x45` (0100 0101) - DRY
- `0x85` (1000 0101) - HEAT
- `0xC5` (1100 0101) - FAN
- `0xC4` (1100 0100) - выключен давно, зима

Встречались и другие значения. Требуется дополнительный анализ.

Какая-то связь с режимами есть, но какая именно - не понятно. Есть в логах такое, когда сплит был выключен в режиме COOL, но это никак не поменяло этот байт (он остался `0x24`). В это время я тестировал включение/выключение сплита и между этими двумя событиями прошло всего 30 сек. Может внешний блок завестись не успел? Потому что дальше при более длительных тестах вроде этот байт менялся согласно режимам…

Возможно, это включение компрессора или вентилятора во внешнем блоке.

На мультисплитсистеме встречались такие значения.

Первый внутренний блок:
- `0xDC` (1101 1100) - выключен
- `0x3D` (0011 1101) - включен на охлаждение, 18 град, подхалим: вверх-вниз включен, вправо-влево включен; fan HIGH; дисплей погашен
- `0x3C` (0011 1100) - выключен после работы в режиме `0x3D`

Второй внутренний блок:
- `0x20` (0010 0000) - выключен
- `0x21` (0010 0001) - включен на охлаждение, 18 град, подхалим: вверх-вниз отключен, вправо-влево отключен; fan HIGH; дисплей работает.
- `0x20` (0010 0000) - выключен после работы в режиме `0x21`

Причем внутренние блоки работали в режимах `[#1 OFF; #2 OFF]` => `[#1 ON; #2 OFF]` => `[#1 ON; #2 ON]` => `[#1 OFF; #2 ON]` => `[#1 OFF; #2 OFF]`. И при изменении на одном блоке этот байт на втором блоке не менялся.


> **Brokly:** Встречались такие значения :
>        `0x00`  0000 0000 - OFF
>        `0x01`  0000 0001 - AUTO // режим авто, нет отдельного бита
>        `0x41`   100 0001 - DRY
>        `0x21`    10 0001 - COOL
>        `0x81`  1000 0001 - HEAT
>        `0xC1`  1100 0001 - FAN  // 7 и 6 бит связаны
>        `0x80`  1000 0000 - продувка после переключения из HEAT в OFF 
>        `0xC5`  1100 0101 - FAN+шторки верх-низ
>        `0xDD`  1101 1101 - FAN+шторки лево-право/верх-низ
>        `0xD9`  1101 1001 - FAN+шторки лево-право
>        `0xD8`  1101 1000 - из FAN+шторки лево-право в OFF
>        `0x39`    11 1001 - COOL+шторки лево-право 
>       Очевидно битовые, но связные, поля, предположительные зависимости  
>       ВНИМАНИЕ : режимы номинальны, например в режиме АВТО нагрев или охлаждение не отображаются 
>        7+6+5     4     3      2    1     0
>        MODE    LouvON  LouH  LouV SLEEP ON/OFF  
>  
>     ФУНКЦМЯ CLEEN, HEALTH, ANTIFUNGUS на данный байт не влияют
>  
>     #define AC_BIG_MASK_MODE  b11100000
>     enum { AC_BIG_MODE_DRY  = 0x40,    // 0100 0000
>            AC_BIG_MODE_COOL = 0x20,    // 0010 0000
>            AC_BIG_MODE_HEAT = 0x80,    // 1000 0000
>            AC_BIG_MODE_FAN  = 0xC0}    // 1100 0000
>     #define AC_BIG_MASK_POWER       b00000001
>     #define AC_BIG_MASK_LOUVERS_ON  b00010000
>     #define AC_BIG_MASK_LOUVERS_H   b00000100
>
>     #define AC_BIG_MASK_LOUVERS_L   b00001000
>     #define AC_BIG_MASK_SLEEP       b00000010
>     #define AC_BIG_MASK_COOL        b00100000

**ВАЖНО!** Обнаружил в логах на Rovex ALS, что бит вертикальных жалюзи для этого кондиционера инвертирован! То есть тут `1`, когда вертикальные жалюзи выключены и `0`, когда вертикальные жалюзи включены!


<span id="packet_cmd_21_frst"/>

##### Байт 12 (FRST)
Вроде бы расшифрован. Требуется проверка.
Говорит о процессе разморозки внешнего блока.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | CL | X  | DF | NDF| X  | X  | X  | X  |

**Бит 4 (NDF)** - needDefrost - начало разморозки (накопление тепла).

**Бит 5 (DF)** - defrostMode - режим разморозки внешнего блока (прогрев испарителя).

**Бит 7 (CL)** - cleen - CLEAN



<span id="packet_cmd_21_fspd"/>

##### Байт 13 (FSPD)
fanSpeed

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | X  | X  | X  | X  | X  | FS3| FS2| FS1|

**Биты 0..2 (FS1..FS3):** реальная скорость вентилятора.  
Возможны следующие значения:

OFF         = `0x00` (0000 0000)
LOW         = `0x02` (0000 0010)
MID         = `0x04` (0000 0100)
HIGH        = `0x06` (0000 0110)
TURBO       = `0x07` (0000 0111)

режим CLEAN = `0x01` (0000 0001)

Но это при ответах на запросы wifi-модуля (TYPE=`0x06` CMD=`0x21`). В дежурных пакетах тут какие-то совсем другие значения.

> **Brokly:** Energolux Bern - подтверждаю, ВАЖНО !!!! Это реальная скорость фена. Та, которая в данный момент. Например может быть установлен нагрев со скоростью вентилятора HI, но кондей еще не произвел достаточно тепла, и крутит на LOW, И тогда тут будет отображаться LOW.
> в дежурных пакетах тут похоже что-то другое



<span id="packet_cmd_21_fpwm"/>

##### Байт 14 (FPWM)
скорость шима вентилятора

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | FP7| FP6| FP5| FP4| FP3| FP2| FP1| ?  |

**Бит 0 (?):** не понятно, что за бит. Как минимум в Rovex ALS встречалась тут `1`. Надо изучать.

**Биты 1..7 (FP1..FP7):** значение ШИМ вентилятора.  
Примерное соответствие:
  126...128 - turbo
  100...113 - hi
  84...85 - mid
  59...62 - low
  0 - off

**TODO:** Нужно уточнить у Brokly, как он получил эти значения. По логам Rovex ALS у меня не получилось соответствие указанным значениям.

> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока здесь встречались самые разные значения. У выключенного сплита тут `0x00`. В мульти-сплите у каждого внутреннего блока изменения тут независимые (при выключенном одном из блоков и включенном втором у выключенного ничего тут не меняется). Когда работает, значения меняются почти каждую посылку.



<span id="packet_cmd_21_tint"/>

##### Байт 15 (Тint)
целая часть температуры внутреннего датчика.

Перевод в градусы цельсия по формуле: T = Тint - `0x20` + Tid/10.  
Где Tid - дробная часть температуры (лежит в **байте 31 (Tid)**).


<span id="packet_cmd_21_int"/>

##### Байт 16 (inT)
не расшифрован.  У меня встречался только `0x00`.

> **Brokly:** В ВЫКЛЮЧЕНОМ СОСТОНИИ значение байт 15, 16, 17, 18 равны! А значит это термодатчики внутри внутреннего блока!

> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока здесь встречались самые разные значения. Для этой системы **байты 16, 17** и **18** имели всегда одинаковые значения. На разных внутренних блоках эти значения были разные и при поочередном включении блоков вроде как значения этих байтов для разных блоков не особо коррелировали.

> **Из сообщества:** на других инверторных системах тут тоже были значения, но разные для **байт 16, 17** и **18**.

> **Brokly:** скорее всего это действительно какая то температура или дельта температур
> СКОРЕЕ ВСЕГО ЭТО ТЕМПЕРАТУРА ПОДАЧИ !!!!!! При охлаждении - холодная, при нагреве теплая
> холоднее или горячее температуры в команте. В выключеном состоянии стремится к комнатной темп.
> у меня на трех инверторных кондиционерах Energolux серии Bern 
> в выключеном состоянии значение этого байта находится на уровне 57-68 (мощность 0%)
> зависит от мощности работы компрессора (измерения при 12гр на улице)
> в режиме охлаждения уменьшается и при мощности 47% = 40 / 73% = 38
> в режиме нагрева увеличивается и при мощности 47% = 70 / 73% = 75 / 84% = 84
> изменение этого значения более вялое, с западыванием относительно изменения мощности
> видимо является реакцией (следствием работы) на изменение мощности инвертора
> учитывая стиль записи температур имеет смысл рассматривать это значение как увеличенное на 0x20

> этот байт как-то связан с температурой во внешнем блоке. Требуются дополнительные исследования.
> При выключенном сплите характер изменения значения примерно соответствует изменению температуры на улице.
> При включенном сплите значение может очень сильно скакать.
> По схеме wiring diagram сплит-системы, во внешнем блоке есть термодатчик, отслеживающий температуру испарителя.
> Возможно, этот байт как раз и отражает изменение температуры на испарителе.
> Но я не смог разобраться, как именно перевести эти значения в градусы.
> Кроме того, зимой даже в минусовую температуру этот байт не уходит ниже 0x33 по крайней мере
> для температур в диапазоне -5..-10 градусов Цельсия.



<span id="packet_cmd_21_int2"/>

##### Байт 17 (To)
Для сплитов on-off похоже на температуру теплообменника во внешнем блоке. Но адекватную формулу определить не получилось.

На температуру внешнего блока очень похоже, так как характер изменений значения в течение суток при выключенном кондиционере, соответствует изменению температуры уличного воздуха. Если кондиционер работает, то при изменении режимов его работы (обогрев, охлаждение) эта температура очень сильно и быстро меняется.

Для инверторов температура внешнего блока в **байте 20 (iT)** (см. ниже). Для мультисплитсистем и инверторов тут какие-то свои значения.

> **Наблюдения.** При -7..-5 градусах на улице в этом байте у меня `0x33`. При дальнейшем понижении температуры до -9..-7 градусов этот байт не изменился (остался `0x33`). Так что либо там какое-то ограничение по нижней температуре, либо что-то еще. Пока сложно понять, как высчитывать температуру.

> **Brokly:** полностью повторяет значение 16 байта



<span id="packet_cmd_21_int3"/>

##### Байт 18
не расшифрован. У меня встречался только `0x00`. Для мультисплитсистем и инверторов тут есть значения.

> **Brokly:** полностью повторяет значение 16 байта



<span id="packet_cmd_21_b19"/>

##### Байт 19
не расшифрован. У меня встречался только `0x00`.
Для мультисплитсистем и инверторов тут есть значения.

> **Brokly:** всегда = 100 (`0x64`)



<span id="packet_cmd_21_b20"/>

##### Байт 20
не расшифрованы. У меня встречались только `0x00`.

> **Brokly Energolux Bern:** Внешняя температура формула T= БАЙТ20 - `0x20`
> Датчик на радиаторе внешнего блока, доступен для пользователя, без разборки блока
> температура внешнего теплообменника влияет на это значение (при работе на обогрев - понижает, при охлаждении или при разморозке - повышает)

> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока здесь самые разные значения. Причем для обоих внутренних блоков они одинаковы! Значит, это какие-то параметры внешнего блока.

> **Из сообщества:** Для RoyalClima18HNI в **байте 20 (iT)** температура внешнего блока.


<span id="packet_cmd_21_b21"/>

##### Байт 21
не расшифрованы. У меня встречались только `0x00`.

> **Из сообщества:** Для RoyalClima18HNI в **байте 21** всегда значение `0x20`.

> **Brokly Energolux Bern:** похоже не какой то Термодатчик  T=Байт_21 - `0x20`
> При охлаждении растет, при нагреве падает, можно делать вывод о режиме COOL или HEAT
> ПОХОЖЕ НА ТЕМПЕРАТУРУ ОБРАТКИ !!!


<span id="packet_cmd_21_b22"/>

##### Байт 22
не расшифрованы. У меня встречались только `0x00`.

> **Из сообщества:** Для RoyalClima18HNI в **байте 22** всегда значене `0x20`.

> **Brokly Energolux Bern:** похоже не какой то Термодатчик T=Байт_22 - `0x20`
> показания РАСТЕТ ПРИ ВКЛЮЧЕНИИ ИНВЕРТОРА, при выключении падают до комнатной
> от режима охлаждения или нагрева не зависит !!!


<span id="packet_cmd_21_b23"/>

##### Байт 23
не расшифрованы. У меня встречались только `0x00`.

> **Brokly Energolux Bern:** всегда  `0x39` (0011 1001)



<span id="packet_cmd_21_b24"/>

##### Байт 24 (iPwr)
В сплитах on-off встречался только `0x00`. Для инверторов тут мощность работы внешнего блока в процентах.

> **Из сообщества:** для инвертора RoyalClima18HNI, в этом байте точно указывается мощность внешнего блока в % от 0 до 100 (`0x00`..`0x64`).
> например, разморозка внешнего блока происходит при 80%

> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока здесь какие-то значения. По логу примерно через 35 сек после включения внутреннего блока тут начинают меняться цифры, и где-то через 56 сек. они устаканиваются на значении `0x1E` (0001 1110) и не меняются до конца работы. Примерно через 35 сек после выключения внутреннего блока тут устанавливается `0x00`. Цифры с работой второго блока не связаны. В логе включались и выключались сплиты последовательно. При этом для блока №1 до установки `0x1E` потребовалось 35 секунд. А для блока №2, который был включен уже при работающем блоке №1, значение `0x1E` появилось через 12 сек (через одну посылку пакета TYPE=`0x07` CMD=`0x21`). Возможно потому, что внешний блок уже был на режиме?



<span id="packet_cmd_21_b25"/>

##### Байт 25
не расшифрован. У меня встречался только `0x00`.

> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока этот байт видимо как-то связан с работой внешнего блока.
В логе внутренние блоки включались в последовательности `[#1 OFF; #2 OFF]` => `[#1 ON; #2 OFF]` => `[#1 ON; #2 ON]` => `[#1 OFF; #2 ON]` => `[#1 OFF; #2 OFF]`. При этом когда оба блока не работали, в этом байте было `0x00`. Когда же хоть один из блоков работал, тут встречались значения от `0x02` до `0x09`.

> **Brokly Energolux Bern:** полное наложение на показания инвертора (от 0 до 22, когда инвертор отключен и тут 0
> при включении инвертора плавно растет, при выключении резко падает в 0, форма графика достаточно плавна



<span id="packet_cmd_21_b26"/>

##### Байт 26
не расшифрован. У меня встречался только `0x00`.
> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока здесь какие-то значения. Они меняются и при выключенных внутренних блоках. Для обоих внутренних блоков значение этого байта меняется примерно синхронно (чаще всего одинаково; иногда есть такое, что для одного из блоков тут какая-то отличающаяся цифра, но это можно объяснить не одновременным считыванием значения).

> **Brokly Energolux Bern:** наложение на показания инвертора (от 144 до 174, когда инвертор отключен показания немного скачут в районе 149...154, при включении инвертора быстро растет, при выключении моментально падает до 149...154, бывают опускания ниже этих значений до 144, чаще в момент первоначального включения инвертора, а потом вверх, не всегда. При включении уходит в 0 на одну посылку



<span id="packet_cmd_21_b27"/>

##### Байт 27
не расшифрован. У меня встречался только `0x00`.
> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока в этом байте `0x02` пока внутренний блок не включен и значения `0x0E`, `0x1E`, `0x20`, `0x22`, `0x24`, `0x26`, `0x28`, `0x2A`, `0x2C`, `0x2E`, `0x30`, `0x32`, `0x36`, `0x38`, `0x3C`.

> Значения для разных блоков не общие (когда блок не работает, у него в этом байте `0x02` для любых значений этого байта у второго блока). При выключении блока №1 (блок №2 работал) значение сменилось на `0x02` через 5 пакетов. При выключении блока №2 (блок №1 уже не работал) значение сменилось на `0x02` через 18 пакетов.

> **Brokly Energolux Bern:** включение 144 -> 124 -> 110 далее все время держим 110



<span id="packet_cmd_21_b28"/>

##### Байт 28
не расшифрован. У меня встречался только `0x00`.

> **Из сообщества:** В мультисплитсистеме на 2 внутренних блока в логе здесь встречаются значения `0x00`..`0x0B`.
Когда оба внутренних блока выключены, тут значение `0x00`.
После включения блока №1 через 3 пакета тут появляется ненулевое значение. Причем у обоих блоков. Но при этом сами значения у блока №1 и №2 могут быть не равны.
После выключения блока №1 (блок №2 продолжает работать) у обоих блоков тут продолжают меняться значения.
После выключения и блока №2 у обоих блоков этот байт обнуляется.

> **Brokly Energolux Bern:** полное наложение на показания инвертора (от 0 до 45, когда инвертор отключен и тут 0
> при включении инвертора плавно растет, при выключении резко падает в 0, форма графика дрожащая нестабильная 
> колебания в районе +-2...4 единицы




<span id="packet_cmd_21_b29"/>

##### Байт 29
не расшифрован. Встречался только `0x00`.



<span id="packet_cmd_21_b30"/>

##### Байт 30
не расшифрован. Встречался только `0x00`.



<span id="packet_cmd_21_b31"/>

##### Байт 31 (Tid)
десятые доли градуса для внутренней температуры. Меняется и при выключенном сплите, и при включенном. Хранятся в прямом виде. Целую часть температуры искать в **байте 15 (Tint)**.

> **Brokly:** Младшие 4 бита - дробная часть комнатной температуры воздуха с датчика на внутреннем блоке сплит-системы, подробнее смотреть ambient_temperature_int

> **для RoyalClima18HNI:** старшие 4 бита - `0x20`. Не понятно, что это значит. У других сплитов такое не встречалось. 


<span id="packet_cmd_11"/>

#### CMD 0x11: Статус внутреннего блока сплит-системы {#type07cmd11}
Отправляется сплитом в ответ на команду модуля wifi с TYPE = `0x06` и CMD = `0x11`.

Входящий пакет:
| #  | NAME  | значение |
| -- | ----- | -------- |
| 0  | START | `0xBB` |
| 1  | ?     | `0x00` |
| 2  | TYPE  | `0x07` |
| 3  | wifi? | `0x00` |
| 4  | ?     | `0x00` |
| 5  | ?     | `0x00` |
| 6  | LEN   | `0x0F` |
| 7  | ?     | `0x00` |
| 8  | ?X    | `0x01` |
| 9  | CMD   | `0x11` |
| 10 | TS    | `0x97` |
| 11 | SL    | `0x00` |
| 12 | Td    | `0x01` |
| 13 | SP    | `0x60` |
| 14 | TB    | `0x00` |
| 15 | MO    | `0x20` |
| 16 |       | `0x00` |
| 17 |       | `0x00` |
| 18 | EN    | `0x20` |
| 19 |       | `0x00` |
| 20 | FL    | `0x00` |
| 21 |       | `0x00` |
| 22 | Tsd   | `0x00` |
| 23 | CRC1  | `0x00` |
| 24 | CRC2  | `0x00` |


##### Байт 8 (?X)
не понятно, что это. Всегда встречался только `0x01`. Есть предположение, что это тот же байт `0x01`, который передает wifi-модуль в пакете TYPE = `0x06` в **байте 9 (?x)**.

В описании к пакету TYPE = `0x06` описана пара возможных экспериментов с этим байтом.


##### Байт 9 (CMD)
возвращает wifi-модулю код типа команды CMD, полученный в пакете TYPE = `0x06`.


##### Байт 10 (TS)
байт хранит целую часть целевой температуры, а также положение вертикальных шторок.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | T5 | T4 | T3 | T2 | T1 | UD3| UD2| UD1|

**Биты T1-T5** - целая часть целевой температуры. Б**иты UD1-UD3** - положение вертикальных шторок.

Целевая температура в градусах определяется так:
```
8 + (байт10 >> 3) + (0.5 * (байт12 >> 7))
```
\>\> - это двоичный сдвиг вправо на указанное количество порядков.
```
(1000 0111 >> 3) = 0001 0000
```

Если UD1 = UD2 = UD3 = 0, то включается вертикальное качание SWING_UD (верх-низ). Если эти биты установлены в 1, то SWING_UD отключен.
> **Версия:** В разных кондеях есть кроме свинга и другие режимы. Например, повернуть только вверх, повернуть полностью вниз, направить по центру… и т.п. Скорее всего протоколом предусмотрены такие режимы. Но кондей может их и не поддерживать. Стоит поэкспериментировать.

> **Из сообщества:** Кондиционер Andi Weiss умеет устанавливать шторки в определенное положение. Он скинул лог, в котором с пульта выставил последовательно разные положения. Значения для разного положения вертикальных шторок:
> `0bXXXXX000` - старт в режиме качания
> `0bXXXXX001` - ?
> `0bXXXXX010` - ?
> `0bXXXXX011` - ?
> `0bXXXXX100` - ?
> `0bXXXXX101` - ?
> `0bXXXXX000` - финиш в том же режиме качания

> **Исследовать!**
> Вариант `0bXXXXX111` в логе Andi тоже был. Это зафиксированное положение шторок. Но почему-то в логе не встретился вариант `0bXXXXX110`. Надо будет его тоже попробовать.


##### Байт 11 (SL)
часть байта хранит горизонтальное положение шторок. Остальная часть байта непонятно для чего.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | LR3| LR2| LR1| X  | X  | X  | X  | X  |

Если LR1 = LR2 = LR3 = 0, то включается качание шторок SWING_LR (лево-право). Если эти биты установлены в 1, то SWING_LR отключен.

> **Версия:** В разных кондеях есть кроме свинга и другие режимы. Например, повернуть только влево, повернуть только вправо, раздвинуть в стороны (левую часть влево, правую часть вправо), направить по центру… и т.п. Скорее всего протоколом предусмотрены такие режимы. Но кондей может их и не поддерживать. Стоит поэкспериментировать.


##### Байт 12 (Td+TMR)
полностью не расшифрован. Часть значения - целевая температура.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | TD | X  |TMR6|TMR5|TMR4|TMR3|TMR2|TMR1|

**Бит 7 (TD)** показывает, есть ли у целевой температуры дробная часть в виде 0,5 градуса (подробнее см. **байт 10 (TS)**).

Минимальное замеченное значение **байта 12 (Td)** = `0x00`, максимальное = `0xAD`.

**Бит 6** не расшифрован. Возможно, всегда равен 0, т.к. других вариантов я не встретил.

**Биты 0..5 (TMR1..TMR6)** - это счетчик минут, прошедших с последней команды ИК-пульта. Каждая новая команда с ИК-пульта обнуляет счетчик. Команды от wifi-донгла счетчик не обнуляют (ни наш на базе ``aux_ac``, ни официальный стик от производителя кондиционера).
Проверка по имеющимся логам показала, что значение счетчика меняется от `0` (`0x00`) до `59` (`0x3B`), после чего опять стартует с нуля.


##### Байт 13 (SP+TH) {#fanSpeedAndTimesHours}
скорость вращения вентилятора сплита.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | SP3| SP2| SP1| TH5| TH4| TH3| TH2| TH1|

**Биты TH1..TH5** задают часы таймера выключения (возможно, и включения тоже) кондиционера. Максимальное значение тут 23 (`0b10111`), хотя для числа в 5 бит можно засунуть и 31. Что при этом получится - не известно, надо проверить :)

> **ВАЖНО:** Хотя в 5 бит вполне влезает значение 24, но для установки 24 часов нужно обнулить минуты таймера в [байте 14](#fanRegAndTimerMinutes) и часы здесь!


**Биты SP1..SP3** задают скорость вращения вентилятора.

Значения следующие:
- AUTO: SP3=1, SP2=0, SP1=1 (`0xA0` если биты 0-4 сброшены в 0) эта скорость поддерживается сплитом в режиме COOL, но отсутствует в режиме FAN;
- LOW: SP3=0, SP2=1, SP1=1 (`0x60` если биты 0-4 сброшены в 0)
- MEDIUM: SP3=0, SP2=1, SP1=0 (`0x40` если биты 0-4 сброшены в 0)
- HIGH: SP3=0, SP2=0, SP1=1 (`0x20` если биты 0-4 сброшены в 0)


##### Байт 14 (TB+MT+TM) {#fanRegAndTimerMinutes}
специальные режимы скорости вентилятора, а также минуты таймера выключения (возможно и включения тоже) кондиционера.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | MT | TB | X  | TM5| TM4| TM3| TM2| TM1|

**Биты TM1..TM5** задают минуты таймера выключения (возможно, и включения тоже) кондиционера. Максимальное значение для числа в 5 бит - 31 минута. Но примет ли его кондиционер - пока не понятно. Надо проверять.

> **Проверить!** С ИК-пульта можно установить только значение 30, возможно пройдут и другие, нужно пробовать. 


**Бит TB** активирует интенсивный режим работы (TURBO). Если TB=1, то функция включена. Если TB=0, то функция выключена.
Функция доступна в режимах COOL и HEAT. Суть: вентилятор начинает вращаться на максимальной скорости для того, чтобы обогреть или охладить помещение как можно скорее.
> **Проверить:** В инструкции заявлено, что переключение режимов сплита или увеличение/уменьшение скорости вращения вентилятора автоматически отключает функцию TURBO. Но не понятно, эта логика реализована в пульте или в кондее. Наверное, в кондее. Но стоит проверить.

Функция TURBO комбинируется в режиме COOL со скоростями LOW, MEDIUM, HIGH. Сделано так, чтобы отмена функции TURBO возвращала установленную ранее скорость вентиляторов. Комбинацию со скоростью AUTO проверить забыл. Режим HEAT не проверял, но должно быть аналогично COOL.

**Бит MT** активирует тихий режим работы (MUTE). Если MT=1, то функция включена. Если MT=0, то функция выключена.


В режиме COOL функция не срабатывает: сплит команду принимает, но в дежурных пакетах в бите MT значение не появляется (остается 0).

В режиме FAN сработало.


##### Байт 15 (MO)
режим работы сплита.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | MD3| MD2| MD1| X  | iFL| SLP| X  | X  |

**Биты MD1-MD3** задают режим работы сплита:
- AUTO:	MD1=0, MD2=0, MD3=0
- COOL:	MD1=1, MD2=0, MD3=0 (`0x20` если биты 0-4 сброшены в 0)
- DRY:	MD1=0, MD2=1, MD3=0 (`0x40` если биты 0-4 сброшены в 0)
- HEAT:	MD1=0, MD2=0, MD3=1 (`0x80` если биты 0-4 сброшены в 0)
- FAN:	MD1=0, MD2=1, MD3=1 (`0xC0` если биты 0-4 сброшены в 0)

**Бит SLP** устанавливает функцию “работа в режиме ночного времени”. Если SLP=1, то функция включена. Если SLP=0, то функция выключена.

Функция доступна только в режиме COOL и HEAT. Выключение сплита функцию сбрасывает. Также функция автоматически сбрасывается через 7 часов.

Принцип работы в каждом из режимов:
- в режиме COOL температура повысится автоматически на 1 градус каждый час в первые два часа работы функции; функция автоматически выключится через 7 часов (по инструкциям не понял, при автоматическом выключении целевая температура возвращается ли к исходной, т.е. -2 градуса).
- в режиме HEAT температура повысится автоматически на 2 градуса каждый час в первые два часа работы функции; функция автоматически выключится через 7 часов (будет ли при этом возврат к исходной целевой температуре - ХЗ).

**Бит iFL (`не проверено!`)** устанавливает для сплита режим iFeel. В этом режиме температура поддерживается около пульта, а не в месте установки кондея. Если iFL=1, то функция включена. Если iFL=0, то функция выключена.
> По факту функция работает через одно место. Не прижилась. Использовать не удобно.


##### Байт 16
не расшифрован, встречался только `0x00`.


##### Байт 17
не расшифрован, встречался только `0x00`.


##### Байт 18 (EN)
говорит о том, в каком режиме включен сплит.

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | X  | TMR| POW| X  | X  | iCL| HL2| HL1|

Если **байт 18 (EN)** равен `0x00`, то сплит выключен (POWER OFF).

**Бит TMR**. Это бит активации функции таймера.  
Установка `1` в этом бите активирует таймер. При этом задержка таймера устанавливается в [байте 13](#fanSpeedAndTimesHours) и [байте 14](#fanRegAndTimerMinutes) этого же пакета.

> **Проверить!** По сообщению Brokly, таймер включается только при включенном кондее. Но мне казалось, что на включение таймер тоже можно было ставить... В общем, этот момент надо изучить.

**Бит POW** = 1 говорит о том, что сплит работает в обычном режиме, когда можно выбирать охлаждение, нагрев и прочие режимы работы.

**Бит iCL** = 1 при **POW** = 0 говорит о том, что сплит включен в режиме самоочистки iCLEAN. Этот режим запускается (или должен запускаться) при выключенном сплите (т.е. **байт 18 (EN)** должен быть установлен целиком в `0x04`).

Режим iCLEAN - это функция продувки испарителя (самоочистка внутреннего блока). В этом режиме вентилятор внутреннего блока автоматически вращается на низкой скорости, жалюзи открыты. Функция удаляет влагу с поверхности испарителя и внутренних полостей внутреннего блока кондиционера (предотвращает появление и рост бактерий, а также образование плесени внутри блока). После установки функции очистки для запуска кондиционера и отключения этой функции необходимо повторно нажать на пульте кнопку iCLEAN или кнопку ON/OFF.
Функция iCLEAN прекратится автоматически по истечении 35 минут работы.

Как я понимаю, это что-то похожее на “антиплесень”, но включается редко, вручную и надолго. Антиплесень работает автоматически после каждого выключения кондея и не так долго.


**Бит HL2** при **POW** = `1` активирует функцию HEALTH (ионизатор воздуха).

*Функция HEALTH проверена пользователями с ионизатором.*
При активации функции HEALTH модуль передаёт команду `0x06` с установленными в `1` битами **POW** и **HL2** **байта 18 (EN)**. При этом бит **POW** уже был ранее установлен, т.к. сплит работал в обычном режиме; **байт 18 (EN)** равен `0x22`.

Если функция включилась, то в рассылаемых сплитом пакетах `0x07` с длиной `0x0f` бит **HL2** будет установлен в `1` до выключения функции.

Выключение функции происходит сбросом в `0` бита **HL2**.

> **Из сообщества (Brokly):** 
> Особенности поведения:
> 1. включается только при включенном кондее
> 2. при включении всегда переводит ifeel в режим ROOM
> 3. при выключении переводит всегда ifeel в режим SET


**Бит HL1** - похоже это бит статуса ионизатора. Появление в этом бите `1` , предположительно сообщает об ошибке включения ионизатора или его некорректной работе.

> В моём сплите ионизатор отсутствует. Попытка включить его установкой бита **HL2** приводит к сбросу сплитом бита **HL2** и установке `1` в бите **HL1**.
> Для выключения функции wifi-модуль сбрасывает бит **HL2**, а бит **HL1** при этом не трогает. То есть сплиту передаётся байт `0x21`. Следующие за этим пакеты `0x07` с длиной `0x0f`, рассылаемые сплитом, уже имеют сброшенный бит **HL1**. То есть приходит байт `0x20`.


##### Байт 19
не расшифрован, встречался только `0x00`.

##### Байт 20 (FL)
флаги включенных функций (дисплей, антиплесень).

| # бита | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
| ------ | -- | -- | -- | -- | -- | -- | -- | -- |
| имя    | X  | X  | X  | DS | MD | X  | X  | X  |

**Бит DS (display)** отвечает за включение и выключение дисплея. Если тут 0, то дисплей погашен, если бит сброшен в 1, то дисплей светится при работе сплита.

> **ВАЖНО!** Есть несоответствие работы с дисплеем на разных моделях кондиционеров. См. [issue #31 "особенности работы дисплея"](https://github.com/GrKoR/esphome_aux_ac_component/issues/31) к компоненту `aux_ac`. Поэтому в компоненте ввел параметр `display_inverted` для корректной работы с кондиционерами Rovex (возможно, есть и другие производители с инвертированным управлением дисплеем). 

**Бит MD (mildew)** отвечает за работу функции “антиплесень”. Если тут 1, то функция включена, если бит сброшен в 0, то функция выключена.

В чем заключается функция "антиплесень", детально не изучал. В сети встретил такое:
> “*После отключения кондиционера, вентиляторы внутреннего блока продолжают свою работу при закрытых жалюзи. Это дает возможность быстро и качественно просушить все внутренние компоненты устройства, удалив избыточную влагу. Положительным следствием такой сушки является удаление посторонних, зачастую неприятных запахов.*”

В общем, он типа сушит теплообменник и прочие внутренности.

По факту протестировал: после выключения сплита он оставляет минут на 5 открытые жалюзи и глушит вентилятор. Уличный блок при этом гудит и тарахтит. Возможно, прогревается теплообменник для высыхания. Через некоторое время внешний блок замолкает и сплит закрывает жалюзи.


##### Байт 21
не расшифрован, встречался только `0x00`.

##### Байт 22 (Tsd)
десятые доли градуса целевой температуры. Встречались только значения `0x00` и `0x05`. Причем в передаваемой команде `0x06` этот байт всегда `0x00` и десятые доли передаются в **байте 12**. Но после установки температуры пакетом `0x06` сплит начинает в пакетах `0x07` в этом байте давать десятые доли. Не очень понятно, зачем такая логика работы. Может, чтобы это могли расшифровать тупые устройства и вывести на экран?





<span id="packet_cmd_01"/>

#### CMD 0x01: Подтверждение выполнения команды управления
Отправляется сплитом как подтверждение получения (или выполнения) команды. В ответ на пакет wifi-модуля с TYPE = `0x06` и CMD = `0x01`.

Входящий пакет:
| #  | NAME  | значение |
| -- | ----- | -------- |
| 0  | START | `0xBB` |
| 1  | ?     | `0x00` |
| 2  | TYPE  | `0x07` |
| 3  | wifi? | `0x00` |
| 4  | ?     | `0x00` |
| 5  | ?     | `0x00` |
| 6  | LEN   | `0x04` |
| 7  | ?     | `0x00` |
| 8  | ?X    | `0x01` |
| 9  | CMD   | `0x01` |
| 10 | sm1   | `0x94` |
| 11 | sm2   | `0xFD` |
| 12 | CRC1  | `0xA4` |
| 13 | CRC2  | `0x00` |


##### Байт 8 (?X)
не понятно, что это. Всегда встречался только `0x01`. Есть предположение, что это тот же байт `0x01`, который передает wifi-модуль в пакете TYPE = `0x06` в **байте 9 (?x)**.

В описании к пакету TYPE = `0x06` описана пара возможных экспериментов с этим байтом.


##### Байт 9 (CMD)
возвращает wifi-модулю код типа команды CMD, полученный в пакете TYPE = `0x06`.


##### Байт 10 (sm1)
Соответствует байту CRC1 поступившего от wifi-модуля пакета с командой (TYPE = `0x06`, CMD = `0x01`).


##### Байт 11 (sm2)
Соответствует байту CRC2 поступившего от wifi-модуля пакета с командой (TYPE = `0x06`, CMD = `0x01`).



<span id="packet_type_init"/>

### 0x09: инициирование wifi-модуля
---

Этот пакет может быть как исходящим, так и входящим.
Пакет отправляется сплитом, если при работающем сплите 8 раз за 10 сек. нажать на пульте кнопку HEALTH. В ответ wifi-модуль отправляет исходящий пакет  того же типа.

Входящий пакет:
| #  | NAME  | значение |
| -- | ----- | -------- |
| 0  | START | `0xBB` |
| 1  | ?     | `0x00` |
| 2  | TYPE  | `0x09` |
| 3  | wifi? | `0x00` |
| 4  | ?     | `0x00` |
| 5  | ?     | `0x00` |
| 6  | LEN   | `0x01` |
| 7  | ?     | `0x00` |
| 8  |       | `0x02` |
| 9  | CRC1  | `0x38` |
| 10 | CRC2  | `0xFF` |

##### Байт 8
не расшифрован. Всегда `0x02`.

Исходящий пакет:
| #  | NAME  | значение |
| -- | ----- | -------- |
| 0  | START | `0xBB` |
| 1  | ?     | `0x00` |
| 2  | TYPE  | `0x09` |
| 3  | wifi? | `0x80` |
| 4  | ?     | `0x01` |
| 5  | ?     | `0x00` |
| 6  | LEN   | `0x00` |
| 7  | ?     | `0x00` |
| 8  | CRC1  | `0x3A` |
| 9  | CRC2  | `0x7F` |

Входящий пакет всегда одинаков. Исходящий пакет (ответ wifi-модуля) тоже всегда один и тот же. По крайней мере за всё время наблюдений вариации не встречались.



<span id="packet_type_unkn"/>

### 0x0B: не понятно
---

Смысл этого пакета не понятен. Модуль такие пакеты рассылает, но сплит на это никак не реагирует.

Пока что есть ощущение, что wifi-модуль отправляет такие пакеты, когда проходит инициализация или что-то такое. Типа только подали питание… Или нажали 8 раз кнопку HEALTH на пульте.

Такие пакеты всегда идут тройками. Модуль отправляет три таких пакета с интервалом между ними порядка 24 мсек.
Иногда таких троек несколько (встречал до трёх троек подряд). В этом случае три пакета передаются с интервалами примерно 24 мсек, потом пауза порядка 35 мсек, потом еще три пакета с паузами 24 мсек, еще пауза 35 мсек, еще три пакета с паузами 24 мсек.

Когда логгировал внешнюю температуру, пакеты TYPE = `0x0B` за 2 с лишним часа записи встретились только раз (традиционная пачка из 3 пакетов), в самом начале записи. Скорее всего потому, что при отключенном ноутбуке висящие на линиях USB-UART переходники глушат сигналы и не дают модулю работать. Он включается при подключении к компу и начинает судорожно слать такие команды.

Встреченные варианты пакета:
| #  | NAME  |  вар.1 | вар.2 | вар.3 | вар.4 |
| -- | ----- | ----- | ----- | ----- | ----- |
| 0  | START | `0xBB` | `0xBB` | `0xBB` | `0xBB` |
| 1  | ?     | `0x00` | `0x00` | `0x00` | `0x00` |
| 2  | TYPE  | `0x0B` | `0x0B` | `0x0B` | `0x0B` |
| 3  | wifi? | `0x80` | `0x80` | `0x80` | `0x80` |
| 4  | ?     | `0x00` | `0x00` | `0x00` | `0x00` |
| 5  | ?     | `0x00` | `0x00` | `0x00` | `0x00` |
| 6  | LEN   | `0x02` | `0x02` | `0x02` | `0x02` |
| 7  | ?     | `0x00` | `0x00` | `0x00` | `0x00` |
| 8  |       | `0x00` | `0x01` | `0x02` | `0x03` |
| 9  |       | `0x00` | `0x00` | `0x00` | `0x00` |
| 10 | CRC1  | `0x37` | `0x36` | `0x35` | `0x34` |
| 11 | CRC2  | `0x7F` | `0x7F` | `0x7F` | `0x7F` |

##### Байт 8
не расшифрован. Возможно, это какой-то счетчик попыток. По крайней мере когда wifi-модуль отправляет серию из пачек по три пакета такого типа, этот байт в пачках может увеличиваться. Внутри одной пачки из трёх пакетов этот байт всегда одинаков. Между пачками может отличаться.



## Последовательности команд

Wifi-модуль для работы и корректного отображения информации в приложении все команды отрабатывает не одиночными пакетами, а последовательностями.

Например, для выключения кондиционера модуль выполняет такую последовательность команд:

1. Перед выключением кондиционера wifi-модуль запрашивает у него статус внутреннего блока (TYPE = `0x06`, CMD = `0x11`)
2. Сплит отвечает пакетом статуса внутреннего блока (TYPE = `0x07`, CMD = `0x11`)
3. Wifi-модуль из тела полученного пакета формирует команду на выключение сплита (правит **байт 18**) и отправляет получившийся пакет кондиционеру (TYPE = `0x06`, CMD = `0x01`)
4. Сплит отвечает подтверждением выключения, в теле которого два байта равны CRC16 пакета, полученного на шаге 3. Команда имеет TYPE = `0x07` и CMD = `0x01`.
5. Wifi-модуль запрашивает статус внутреннего блока для отображения в приложении (TYPE = `0x06`, CMD = `0x11`)
6. Сплит отвечает статусом внутреннего блока (TYPE = `0x07`, CMD = `0x11`). **Байт 18** пакета будет соответствовать выключенному сплиту.

Между командами 4 и 5 могут быть другие команды. Команды 5 и 6 привел просто для иллюстрации изменений.

